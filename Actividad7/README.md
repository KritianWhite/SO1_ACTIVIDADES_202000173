# Completely Fair Scheduler - Actividad 7

El Completely Fair Scheduler `(CFS)` de Linux es un algoritmo de programación predeterminado introducido en la `versión 2.6.23 del kernel`, reemplazando al anterior algoritmo `O(1)`. Diseñado para proporcionar una distribución equitativa del tiempo de procesador entre las tareas, el CFS se basa en clases de programación, asignando a cada clase una prioridad específica para atender diversas necesidades del sistema y sus procesos.

El funcionamiento del CFS se distingue por no asignar cuantías de tiempo fijo `(time slices)` a las tareas, sino por determinar proporcionalmente el tiempo de CPU que recibe cada tarea según su valor `'nice'`, que varía entre -20 y +19, donde un valor 'nice' más bajo indica una mayor prioridad. Esta asignación de tiempo se basa en una latencia objetivo, que es el intervalo de tiempo durante el cual cada tarea debe ejecutarse al menos una vez. La latencia objetivo se ajusta en función del número de tareas activas, incrementándose si este número supera un umbral determinado.

- El CFS registra el tiempo de ejecución virtual de cada tarea a través de la variable `vruntime`, que se ajusta según la prioridad de la tarea, permitiendo que tareas de menor prioridad acumulen un `vruntime` más rápido que las de mayor prioridad. La tarea seleccionada para ejecutarse a continuación es aquella con el menor valor de `vruntime`.

- El CFS utiliza un árbol rojo-negro, una estructura de datos de árbol binario balanceado, para almacenar las tareas ejecutables, clasificándolas por su `vruntime`. Esto permite que el algoritmo identifique eficientemente la tarea con el menor `vruntime` para su ejecución, manteniendo así un sistema equitativo y eficiente. Además, el CFS soporta la programación en tiempo real mediante políticas SCHED FIFO y SCHED RR, donde las tareas de tiempo real tienen prioridad sobre las tareas normales.

- El CFS también se destaca por su capacidad de balance de carga, ajustando la distribución del trabajo entre los núcleos de procesamiento y considerando la arquitectura de acceso a memoria no uniforme (NUMA) para minimizar las penalizaciones por acceso a memoria en sistemas multiprocesador. Implementa dominios de programación que agrupan los núcleos según compartan recursos, optimizando el balanceo de carga desde el nivel más bajo de la jerarquía y evitando migraciones de tareas que puedan afectar negativamente el rendimiento debido a penalizaciones de latencia de memoria.
